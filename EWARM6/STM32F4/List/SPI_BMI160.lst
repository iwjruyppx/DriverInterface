###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.4.12462/W32 for ARM       27/Nov/2017  14:39:06
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Paul\Desktop\simulation\DriverInterface\SPI_BMI160.c
#    Command line =  
#        C:\Users\Paul\Desktop\simulation\DriverInterface\SPI_BMI160.c -D
#        USE_STDPERIPH_DRIVER -D VECT_TAB_FLASH -D USE_STM32F4_EVB -D STM32F4XX
#        -D STM32F401X -D AKM_MAGNETOMETER_AK09911 -D AKSC_VERSION_DEVICE=9911
#        -D AKL_SKIP_HW_CHECK -D DEBUG -D AKM_DISABLE_DOEPLUS -D
#        AKM_CUSTOM_CONTINUOUS_MEASURE -D __DOEAG_MODE_EN -D ACC_SENSOR_DISABLE
#        -D AKM_ACCELEROMETER_DUMMY -D AKM_ENABLE_PDC -lC
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\STM32F4\List
#        -lA
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\STM32F4\List
#        --diag_suppress Pa082,pe191 -o
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\STM32F4\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\Libraries\STM32_Common\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\Libraries\STM32F4xx_HAL_Driver\inc\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\Libraries\CMSIS\Device\STM32F4xx\Include\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\..\FreeRTOS\FreeRTOS821\Source\include\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\..\FreeRTOS\FreeRTOS821\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\Libraries\STM32_CPAL_Driver\inc\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\Libraries\STM32_CPAL_Driver\devices\stm32f4xx\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\..\System\Algorithm\inc\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\..\System\Driver\inc\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\..\System\DriverLibrary\AKM8963\inc\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\..\System\DriverLibrary\AKM09911\inc\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\..\System\DriverLibrary\AKM09911AG\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\..\System\DriverLibrary\AKM09911AG\AKM_HAL\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\..\System\DriverLibrary\AKM09911AG\AKM_Library\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\..\System\DriverLibrary\AKM09911AG\AKM_Library\libag\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\..\System\DriverLibrary\AKM09911AG\AKM_Library\libSmartCompass\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\..\System\DriverLibrary\AKM09911AG\AKM_Sensors\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\..\System\DriverLibrary\MMC3524xPJ\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\..\System\DriverLibrary\ST480M\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\..\System\DriverLibrary\Yamaha\inc\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\..\System\DriverLibrary\YamahaMini\inc\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\..\System\Manager\inc\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\..\System\Utils\inc\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\Release\Driver\inc\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\Release\Manager\inc\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\Release\Platform\inc\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\Release\RtosTask\inc\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\Release\System\inc\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\Release\SystemConfig\inc\
#        -I
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\..\..\Source\inc\
#        -I C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\..\..\..\
#        -I C:\work\Develop\Source\Manager\ -I C:\work\Develop\Source\Common\
#        -I C:\work\Develop\Source\Platform_Dependent\ -I
#        C:\work\Develop\Source\Android\ -I C:\work\Develop\Source\TimeSync\ -I
#        C:\work\Develop\Source\Protocol\ -On --vla --use_c++_inline -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    Locale       =  Chinese (Traditional)_Taiwan.950
#    List file    =  
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\STM32F4\List\SPI_BMI160.lst
#    Object file  =  
#        C:\Users\Paul\Desktop\simulation\DriverInterface\EWARM6\STM32F4\Obj\SPI_BMI160.o
#
###############################################################################

C:\Users\Paul\Desktop\simulation\DriverInterface\SPI_BMI160.c
      1          
      2          #ifndef __DriverHal_H__
      3          #define __DriverHal_H__
      4          
      5          /* Standard includes. */
      6          #include <stdio.h>
      7          #include <stdint.h>
      8          #include <errno.h>
      9          #include <string.h>
     10          #include <math.h>
     11          #include <stdlib.h>
     12          #include <stdarg.h>
     13          #include "DriverHal_1_0_Config.h"
     14          #include "SPI_BMI160_DEF.h"
     15          #include "SPI_BMI160.h"
     16          
     17          #define BMI160_ACC_NORMAL_EN					0
     18          #define BMI160_ACC_SPECIAL_EN					1
     19          
     20          typedef struct {
     21              uint8_t infoAccEn;
     22              uint8_t accRate;
     23              uint8_t accMode;
     24          
     25              uint8_t infoGyroEn;
     26          } Bmi160Handle_t, *pBmi160Handle_t;
     27          

   \                                 In section .bss, align 4
     28          static Bmi160Handle_t BMI160;
   \                     BMI160:
   \   00000000                      DS8 4
     29          

   \                                 In section .text, align 2, keep-with-next
     30          static int Read(pDriverHandle_t pHandle, uint8_t reg, uint8_t *data, int len)
     31          {
   \                     Read: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
     32              BusTxRxPackage info = {.type = TYPE_SPI, .address = pHandle->config.slaveAddr, .reg = reg, .data = data, .len = len};
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000010   0xC80F             LDM      R0,{R0-R3}
   \   00000012   0x46EC             MOV      R12,SP
   \   00000014   0xE88C 0x000F      STM      R12,{R0-R3}
   \   00000018   0x8920             LDRH     R0,[R4, #+8]
   \   0000001A   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0xF8AD 0x5006      STRH     R5,[SP, #+6]
   \   00000024   0x9702             STR      R7,[SP, #+8]
   \   00000026   0x9603             STR      R6,[SP, #+12]
     33              return pHandle->api->Read( &info);
   \   00000028   0x4668             MOV      R0,SP
   \   0000002A   0x69E1             LDR      R1,[R4, #+28]
   \   0000002C   0x6809             LDR      R1,[R1, #+0]
   \   0000002E   0x4788             BLX      R1
   \   00000030   0xB005             ADD      SP,SP,#+20
   \   00000032   0xBDF0             POP      {R4-R7,PC}       ;; return
     34          }

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x00000001         DC32 1
   \   00000004   0x0000 0x0000      DC16 0, 0
   \   00000008   0x00000000         DC32 0, 0H
   \              0x00000000   
     35          

   \                                 In section .text, align 2, keep-with-next
     36          static int Write(pDriverHandle_t pHandle, uint8_t reg, uint8_t *data, int len)
     37          {
   \                     Write: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
     38              BusTxRxPackage info = {.type = TYPE_SPI, .address = pHandle->config.slaveAddr, .reg = reg, .data = data, .len = len};
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \   00000010   0xC80F             LDM      R0,{R0-R3}
   \   00000012   0x46EC             MOV      R12,SP
   \   00000014   0xE88C 0x000F      STM      R12,{R0-R3}
   \   00000018   0x8920             LDRH     R0,[R4, #+8]
   \   0000001A   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0xF8AD 0x5006      STRH     R5,[SP, #+6]
   \   00000024   0x9702             STR      R7,[SP, #+8]
   \   00000026   0x9603             STR      R6,[SP, #+12]
     39              return pHandle->api->Write( &info);
   \   00000028   0x4668             MOV      R0,SP
   \   0000002A   0x69E1             LDR      R1,[R4, #+28]
   \   0000002C   0x6849             LDR      R1,[R1, #+4]
   \   0000002E   0x4788             BLX      R1
   \   00000030   0xB005             ADD      SP,SP,#+20
   \   00000032   0xBDF0             POP      {R4-R7,PC}       ;; return
     40          }

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x00000001         DC32 1
   \   00000004   0x0000 0x0000      DC16 0, 0
   \   00000008   0x00000000         DC32 0, 0H
   \              0x00000000   
     41          

   \                                 In section .text, align 2, keep-with-next
     42          static void sleep(pDriverHandle_t pHandle, uint32_t time)
     43          {
   \                     sleep: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     44              pHandle->api->uSleep(time * 1000);
   \   00000006   0xF44F 0x707A      MOV      R0,#+1000
   \   0000000A   0xFB00 0xF005      MUL      R0,R0,R5
   \   0000000E   0x69E1             LDR      R1,[R4, #+28]
   \   00000010   0x6889             LDR      R1,[R1, #+8]
   \   00000012   0x4788             BLX      R1
     45          }
   \   00000014   0xBD31             POP      {R0,R4,R5,PC}    ;; return
     46          

   \                                 In section .text, align 2, keep-with-next
     47          static int64_t getTimeUs(pDriverHandle_t pHandle)
     48          {
   \                     getTimeUs: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     49              return pHandle->api->GetTimeNs()/1000ll;
   \   00000004   0x69E0             LDR      R0,[R4, #+28]
   \   00000006   0x68C0             LDR      R0,[R0, #+12]
   \   00000008   0x4780             BLX      R0
   \   0000000A   0xF44F 0x727A      MOV      R2,#+1000
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x.... 0x....      BL       __aeabi_ldivmod
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
     50          }
     51          

   \                                 In section .text, align 2, keep-with-next
     52          static void error(pDriverHandle_t pHandle, int error, void *data)
     53          {
   \                     error: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
     54              pHandle->api->Error(error, 0);
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x0028             MOVS     R0,R5
   \   0000000C   0x69E2             LDR      R2,[R4, #+28]
   \   0000000E   0x6912             LDR      R2,[R2, #+16]
   \   00000010   0x4790             BLX      R2
     55          }
   \   00000012   0xBD70             POP      {R4-R6,PC}       ;; return
     56          

   \                                 In section .text, align 2, keep-with-next
     57          static void senDataCb(pDriverHandle_t pHandle, float *senData, void *reserved)
     58          {
   \                     senDataCb: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
     59              pHandle->api->DataCb(senData, reserved);
   \   00000008   0x0031             MOVS     R1,R6
   \   0000000A   0x0028             MOVS     R0,R5
   \   0000000C   0x69E2             LDR      R2,[R4, #+28]
   \   0000000E   0x6952             LDR      R2,[R2, #+20]
   \   00000010   0x4790             BLX      R2
     60          }
   \   00000012   0xBD70             POP      {R4-R6,PC}       ;; return
     61          

   \                                 In section .text, align 2, keep-with-next
     62          int AccSetMode(pDriverHandle_t pHandle, int mode){
   \                     AccSetMode: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     63          	uint8_t data1 = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF88D 0x0000      STRB     R0,[SP, #+0]
     64          	uint8_t data2 = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xF88D 0x0001      STRB     R0,[SP, #+1]
     65          	if(mode & (1<<MODE_ACC_MOTION_INT)){
   \   00000012   0x0628             LSLS     R0,R5,#+24
   \   00000014   0xF140 0x80B7      BPL.W    ??AccSetMode_0
     66          		if(BMI160.accMode == MODE_ACC_MOTION_INT){
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   0000001C   0x7880             LDRB     R0,[R0, #+2]
   \   0000001E   0x2807             CMP      R0,#+7
   \   00000020   0xF040 0x8115      BNE.W    ??AccSetMode_1
     67          			if(pHandle->config.privateSetting[2] !=INTERRUPT_OFF){
   \   00000024   0x7B20             LDRB     R0,[R4, #+12]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xF000 0x8111      BEQ.W    ??AccSetMode_1
     68          				data1 =pHandle->config.privateSetting[3];
   \   0000002C   0x7B60             LDRB     R0,[R4, #+13]
   \   0000002E   0xF88D 0x0000      STRB     R0,[SP, #+0]
     69          				data2 =0x00;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xF88D 0x0001      STRB     R0,[SP, #+1]
     70          				if(Write(pHandle,BMI160_INT_MOTION_0_REG,&data1 ,1) ){
   \   00000038   0x2301             MOVS     R3,#+1
   \   0000003A   0x466A             MOV      R2,SP
   \   0000003C   0x215F             MOVS     R1,#+95
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       Write
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD002             BEQ.N    ??AccSetMode_2
     71          					return CWM_ERROR_SPI;
   \   00000048   0xF07F 0x0006      MVNS     R0,#+6
   \   0000004C   0xE100             B.N      ??AccSetMode_3
     72          				}
     73          #ifdef BMI160_USE_MOTION
     74          				data1 =BMI160_INT_EN_ANYMO_CONFIG;
   \                     ??AccSetMode_2: (+1)
   \   0000004E   0x2007             MOVS     R0,#+7
   \   00000050   0xF88D 0x0000      STRB     R0,[SP, #+0]
     75          				if(Write(pHandle,BMI160_INT_EN_0_REG,&data1 ,1) ){
   \   00000054   0x2301             MOVS     R3,#+1
   \   00000056   0x466A             MOV      R2,SP
   \   00000058   0x2150             MOVS     R1,#+80
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x.... 0x....      BL       Write
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD002             BEQ.N    ??AccSetMode_4
     76          					return CWM_ERROR_SPI;
   \   00000064   0xF07F 0x0006      MVNS     R0,#+6
   \   00000068   0xE0F2             B.N      ??AccSetMode_3
     77          				}
     78          				data1 = pHandle->config.privateSetting[0];	 //any motion threshold setting by user
   \                     ??AccSetMode_4: (+1)
   \   0000006A   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000006C   0xF88D 0x0000      STRB     R0,[SP, #+0]
     79          				if(Write(pHandle,BMI160_INT_MOTION_1_REG,&data1 ,1) ){
   \   00000070   0x2301             MOVS     R3,#+1
   \   00000072   0x466A             MOV      R2,SP
   \   00000074   0x2160             MOVS     R1,#+96
   \   00000076   0x0020             MOVS     R0,R4
   \   00000078   0x.... 0x....      BL       Write
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD002             BEQ.N    ??AccSetMode_5
     80          					return CWM_ERROR_SPI;
   \   00000080   0xF07F 0x0006      MVNS     R0,#+6
   \   00000084   0xE0E4             B.N      ??AccSetMode_3
     81          				}
     82          #endif
     83          #ifdef BMI160_USE_NO_MOTION
     84          				data1 =BMI160_INT_EN_NOMO_CONFIG;
   \                     ??AccSetMode_5: (+1)
   \   00000086   0x2007             MOVS     R0,#+7
   \   00000088   0xF88D 0x0000      STRB     R0,[SP, #+0]
     85          				if(Write(pHandle,BMI160_INT_EN_2_REG,&data1 ,1) ){
   \   0000008C   0x2301             MOVS     R3,#+1
   \   0000008E   0x466A             MOV      R2,SP
   \   00000090   0x2152             MOVS     R1,#+82
   \   00000092   0x0020             MOVS     R0,R4
   \   00000094   0x.... 0x....      BL       Write
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD002             BEQ.N    ??AccSetMode_6
     86          					return CWM_ERROR_SPI;
   \   0000009C   0xF07F 0x0006      MVNS     R0,#+6
   \   000000A0   0xE0D6             B.N      ??AccSetMode_3
     87          				}
     88          				data1 = pHandle->config.privateSetting[1];	 //non motion threshold setting by user
   \                     ??AccSetMode_6: (+1)
   \   000000A2   0x7AE0             LDRB     R0,[R4, #+11]
   \   000000A4   0xF88D 0x0000      STRB     R0,[SP, #+0]
     89          				if(Write(pHandle,BMI160_INT_MOTION_2_REG,&data1 ,1) ){
   \   000000A8   0x2301             MOVS     R3,#+1
   \   000000AA   0x466A             MOV      R2,SP
   \   000000AC   0x2161             MOVS     R1,#+97
   \   000000AE   0x0020             MOVS     R0,R4
   \   000000B0   0x.... 0x....      BL       Write
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD002             BEQ.N    ??AccSetMode_7
     90          					return CWM_ERROR_SPI;
   \   000000B8   0xF07F 0x0006      MVNS     R0,#+6
   \   000000BC   0xE0C8             B.N      ??AccSetMode_3
     91          				}
     92          				data1 = BMI160_INT_EN_NOMO_SEL;	 
   \                     ??AccSetMode_7: (+1)
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0xF88D 0x0000      STRB     R0,[SP, #+0]
     93          				if(Write(pHandle,BMI160_INT_MOTION_3_REG,&data1 ,1) ){
   \   000000C4   0x2301             MOVS     R3,#+1
   \   000000C6   0x466A             MOV      R2,SP
   \   000000C8   0x2162             MOVS     R1,#+98
   \   000000CA   0x0020             MOVS     R0,R4
   \   000000CC   0x.... 0x....      BL       Write
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD002             BEQ.N    ??AccSetMode_8
     94          					return CWM_ERROR_SPI;
   \   000000D4   0xF07F 0x0006      MVNS     R0,#+6
   \   000000D8   0xE0BA             B.N      ??AccSetMode_3
     95          				}
     96          				
     97          #endif
     98          				if(pHandle->config.privateSetting[2] == INTERRUPT_USE_INT1){	//int 1
   \                     ??AccSetMode_8: (+1)
   \   000000DA   0x7B20             LDRB     R0,[R4, #+12]
   \   000000DC   0x2801             CMP      R0,#+1
   \   000000DE   0xD129             BNE.N    ??AccSetMode_9
     99          					data1 = BMI160_INT_1_OUTPUT_EN_CONFIG ;
   \   000000E0   0x2008             MOVS     R0,#+8
   \   000000E2   0xF88D 0x0000      STRB     R0,[SP, #+0]
    100          					if(Write(pHandle,BMI160_INT_OUT_CTRL_REG,&data1 ,1) ){
   \   000000E6   0x2301             MOVS     R3,#+1
   \   000000E8   0x466A             MOV      R2,SP
   \   000000EA   0x2153             MOVS     R1,#+83
   \   000000EC   0x0020             MOVS     R0,R4
   \   000000EE   0x.... 0x....      BL       Write
   \   000000F2   0x2800             CMP      R0,#+0
   \   000000F4   0xD002             BEQ.N    ??AccSetMode_10
    101          						return CWM_ERROR_SPI;
   \   000000F6   0xF07F 0x0006      MVNS     R0,#+6
   \   000000FA   0xE0A9             B.N      ??AccSetMode_3
    102          					}
    103          					data2 =0x00;
   \                     ??AccSetMode_10: (+1)
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0xF88D 0x0001      STRB     R0,[SP, #+1]
    104          #ifdef BMI160_USE_MOTION
    105          					data2 |=BMI160_INT_MAP_EN_ANYMO_CONFIG;
   \   00000102   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000106   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000010A   0xF88D 0x0001      STRB     R0,[SP, #+1]
    106          #endif
    107          #ifdef BMI160_USE_NO_MOTION
    108          					data2 |=BMI160_INT_MAP_EN_NOMO_CONFIG;
   \   0000010E   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000112   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000116   0xF88D 0x0001      STRB     R0,[SP, #+1]
    109          #endif
    110          					if(Write(pHandle,BMI160_INT_MAP_0_REG,&data2 ,1) ){
   \   0000011A   0x2301             MOVS     R3,#+1
   \   0000011C   0xF10D 0x0201      ADD      R2,SP,#+1
   \   00000120   0x2155             MOVS     R1,#+85
   \   00000122   0x0020             MOVS     R0,R4
   \   00000124   0x.... 0x....      BL       Write
   \   00000128   0x2800             CMP      R0,#+0
   \   0000012A   0xF000 0x8090      BEQ.W    ??AccSetMode_1
    111          						return CWM_ERROR_SPI;
   \   0000012E   0xF07F 0x0006      MVNS     R0,#+6
   \   00000132   0xE08D             B.N      ??AccSetMode_3
    112          					}
    113          				}else{	//int 2
    114          					data1 = BMI160_INT_2_OUTPUT_EN_CONFIG ;
   \                     ??AccSetMode_9: (+1)
   \   00000134   0x2080             MOVS     R0,#+128
   \   00000136   0xF88D 0x0000      STRB     R0,[SP, #+0]
    115          					if(Write(pHandle,BMI160_INT_OUT_CTRL_REG,&data1 ,1) ){
   \   0000013A   0x2301             MOVS     R3,#+1
   \   0000013C   0x466A             MOV      R2,SP
   \   0000013E   0x2153             MOVS     R1,#+83
   \   00000140   0x0020             MOVS     R0,R4
   \   00000142   0x.... 0x....      BL       Write
   \   00000146   0x2800             CMP      R0,#+0
   \   00000148   0xD002             BEQ.N    ??AccSetMode_11
    116          						return CWM_ERROR_SPI;
   \   0000014A   0xF07F 0x0006      MVNS     R0,#+6
   \   0000014E   0xE07F             B.N      ??AccSetMode_3
    117          					}
    118          					data2 =0x00;
   \                     ??AccSetMode_11: (+1)
   \   00000150   0x2000             MOVS     R0,#+0
   \   00000152   0xF88D 0x0001      STRB     R0,[SP, #+1]
    119          #ifdef BMI160_USE_MOTION
    120          					data2 |=BMI160_INT_MAP_EN_ANYMO_CONFIG;
   \   00000156   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000015A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000015E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    121          #endif
    122          #ifdef BMI160_USE_NO_MOTION
    123          					data2 |=BMI160_INT_MAP_EN_NOMO_CONFIG;
   \   00000162   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000166   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000016A   0xF88D 0x0001      STRB     R0,[SP, #+1]
    124          #endif
    125          					if(Write(pHandle,BMI160_INT_MAP_2_REG,&data2 ,1) ){
   \   0000016E   0x2301             MOVS     R3,#+1
   \   00000170   0xF10D 0x0201      ADD      R2,SP,#+1
   \   00000174   0x2157             MOVS     R1,#+87
   \   00000176   0x0020             MOVS     R0,R4
   \   00000178   0x.... 0x....      BL       Write
   \   0000017C   0x2800             CMP      R0,#+0
   \   0000017E   0xD066             BEQ.N    ??AccSetMode_1
    126          						return CWM_ERROR_SPI;
   \   00000180   0xF07F 0x0006      MVNS     R0,#+6
   \   00000184   0xE064             B.N      ??AccSetMode_3
    127          					}
    128          				}
    129          			}
    130          		}
    131          	}else{
    132          		if(BMI160.accMode == MODE_ACC_MOTION_INT){
   \                     ??AccSetMode_0: (+1)
   \   00000186   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   0000018A   0x7880             LDRB     R0,[R0, #+2]
   \   0000018C   0x2807             CMP      R0,#+7
   \   0000018E   0xD15E             BNE.N    ??AccSetMode_1
    133          			if(pHandle->config.privateSetting[2] !=INTERRUPT_OFF){
   \   00000190   0x7B20             LDRB     R0,[R4, #+12]
   \   00000192   0x2800             CMP      R0,#+0
   \   00000194   0xD05B             BEQ.N    ??AccSetMode_1
    134          				data2 =0x00;
   \   00000196   0x2000             MOVS     R0,#+0
   \   00000198   0xF88D 0x0001      STRB     R0,[SP, #+1]
    135          #ifdef BMI160_USE_MOTION
    136          				data1 =0x00;
   \   0000019C   0x2000             MOVS     R0,#+0
   \   0000019E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    137          				if(Write(pHandle,BMI160_INT_EN_0_REG,&data1 ,1) ){
   \   000001A2   0x2301             MOVS     R3,#+1
   \   000001A4   0x466A             MOV      R2,SP
   \   000001A6   0x2150             MOVS     R1,#+80
   \   000001A8   0x0020             MOVS     R0,R4
   \   000001AA   0x.... 0x....      BL       Write
   \   000001AE   0x2800             CMP      R0,#+0
   \   000001B0   0xD002             BEQ.N    ??AccSetMode_12
    138          					return CWM_ERROR_SPI;
   \   000001B2   0xF07F 0x0006      MVNS     R0,#+6
   \   000001B6   0xE04B             B.N      ??AccSetMode_3
    139          				}
    140          #endif
    141          #ifdef BMI160_USE_NO_MOTION
    142          				data1 =0x00;
   \                     ??AccSetMode_12: (+1)
   \   000001B8   0x2000             MOVS     R0,#+0
   \   000001BA   0xF88D 0x0000      STRB     R0,[SP, #+0]
    143          				if(Write(pHandle,BMI160_INT_EN_2_REG,&data1 ,1) ){
   \   000001BE   0x2301             MOVS     R3,#+1
   \   000001C0   0x466A             MOV      R2,SP
   \   000001C2   0x2152             MOVS     R1,#+82
   \   000001C4   0x0020             MOVS     R0,R4
   \   000001C6   0x.... 0x....      BL       Write
   \   000001CA   0x2800             CMP      R0,#+0
   \   000001CC   0xD002             BEQ.N    ??AccSetMode_13
    144          					return CWM_ERROR_SPI;
   \   000001CE   0xF07F 0x0006      MVNS     R0,#+6
   \   000001D2   0xE03D             B.N      ??AccSetMode_3
    145          				}				
    146          #endif
    147          				if(pHandle->config.privateSetting[2] == INTERRUPT_USE_INT1){	//int 1
   \                     ??AccSetMode_13: (+1)
   \   000001D4   0x7B20             LDRB     R0,[R4, #+12]
   \   000001D6   0x2801             CMP      R0,#+1
   \   000001D8   0xD11C             BNE.N    ??AccSetMode_14
    148          					data1 = 0x00 ;
   \   000001DA   0x2000             MOVS     R0,#+0
   \   000001DC   0xF88D 0x0000      STRB     R0,[SP, #+0]
    149          					if(Write(pHandle,BMI160_INT_OUT_CTRL_REG,&data1 ,1) ){
   \   000001E0   0x2301             MOVS     R3,#+1
   \   000001E2   0x466A             MOV      R2,SP
   \   000001E4   0x2153             MOVS     R1,#+83
   \   000001E6   0x0020             MOVS     R0,R4
   \   000001E8   0x.... 0x....      BL       Write
   \   000001EC   0x2800             CMP      R0,#+0
   \   000001EE   0xD002             BEQ.N    ??AccSetMode_15
    150          						return CWM_ERROR_SPI;
   \   000001F0   0xF07F 0x0006      MVNS     R0,#+6
   \   000001F4   0xE02C             B.N      ??AccSetMode_3
    151          					}
    152          					data2 =0x00;
   \                     ??AccSetMode_15: (+1)
   \   000001F6   0x2000             MOVS     R0,#+0
   \   000001F8   0xF88D 0x0001      STRB     R0,[SP, #+1]
    153          					if(Write(pHandle,BMI160_INT_MAP_0_REG,&data2 ,1) ){
   \   000001FC   0x2301             MOVS     R3,#+1
   \   000001FE   0xF10D 0x0201      ADD      R2,SP,#+1
   \   00000202   0x2155             MOVS     R1,#+85
   \   00000204   0x0020             MOVS     R0,R4
   \   00000206   0x.... 0x....      BL       Write
   \   0000020A   0x2800             CMP      R0,#+0
   \   0000020C   0xD01F             BEQ.N    ??AccSetMode_1
    154          						return CWM_ERROR_SPI;
   \   0000020E   0xF07F 0x0006      MVNS     R0,#+6
   \   00000212   0xE01D             B.N      ??AccSetMode_3
    155          					}
    156          				}else{	//int 2
    157          					data1 = 0x00 ;
   \                     ??AccSetMode_14: (+1)
   \   00000214   0x2000             MOVS     R0,#+0
   \   00000216   0xF88D 0x0000      STRB     R0,[SP, #+0]
    158          					if(Write(pHandle,BMI160_INT_OUT_CTRL_REG,&data1 ,1) ){
   \   0000021A   0x2301             MOVS     R3,#+1
   \   0000021C   0x466A             MOV      R2,SP
   \   0000021E   0x2153             MOVS     R1,#+83
   \   00000220   0x0020             MOVS     R0,R4
   \   00000222   0x.... 0x....      BL       Write
   \   00000226   0x2800             CMP      R0,#+0
   \   00000228   0xD002             BEQ.N    ??AccSetMode_16
    159          						return CWM_ERROR_SPI;
   \   0000022A   0xF07F 0x0006      MVNS     R0,#+6
   \   0000022E   0xE00F             B.N      ??AccSetMode_3
    160          					}
    161          					data2 =0x00;
   \                     ??AccSetMode_16: (+1)
   \   00000230   0x2000             MOVS     R0,#+0
   \   00000232   0xF88D 0x0001      STRB     R0,[SP, #+1]
    162          					if(Write(pHandle,BMI160_INT_MAP_2_REG,&data2 ,1) ){
   \   00000236   0x2301             MOVS     R3,#+1
   \   00000238   0xF10D 0x0201      ADD      R2,SP,#+1
   \   0000023C   0x2157             MOVS     R1,#+87
   \   0000023E   0x0020             MOVS     R0,R4
   \   00000240   0x.... 0x....      BL       Write
   \   00000244   0x2800             CMP      R0,#+0
   \   00000246   0xD002             BEQ.N    ??AccSetMode_1
    163          						return CWM_ERROR_SPI;
   \   00000248   0xF07F 0x0006      MVNS     R0,#+6
   \   0000024C   0xE000             B.N      ??AccSetMode_3
    164          					}
    165          				}
    166          			}
    167          		}
    168          	}
    169          	return 0;
   \                     ??AccSetMode_1: (+1)
   \   0000024E   0x2000             MOVS     R0,#+0
   \                     ??AccSetMode_3: (+1)
   \   00000250   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    170          }
    171          

   \                                 In section .text, align 2, keep-with-next
    172          static int AccSetRate(pDriverHandle_t pHandle, int rate){
   \                     AccSetRate: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    173          	uint8_t data1 = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    174          	uint8_t data2 = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF88D 0x0001      STRB     R0,[SP, #+1]
    175          	int rty = 0;
   \   00000014   0x2600             MOVS     R6,#+0
    176          retry:
    177          	data1 = 0x20;
   \                     ??AccSetRate_0: (+1)
   \   00000016   0x2020             MOVS     R0,#+32
   \   00000018   0xF88D 0x0000      STRB     R0,[SP, #+0]
    178          	if(rate == FASTEST){
   \   0000001C   0x2D0A             CMP      R5,#+10
   \   0000001E   0xD106             BNE.N    ??AccSetRate_1
    179          		data2 = data1 | BMI160_ACC_CONF_RATE_400;
   \   00000020   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000024   0xF050 0x000A      ORRS     R0,R0,#0xA
   \   00000028   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   0000002C   0xE03B             B.N      ??AccSetRate_2
    180          	}else if(rate == GAME){
   \                     ??AccSetRate_1: (+1)
   \   0000002E   0x2D14             CMP      R5,#+20
   \   00000030   0xD106             BNE.N    ??AccSetRate_3
    181          		data2 = data1 | BMI160_ACC_CONF_RATE_400;
   \   00000032   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000036   0xF050 0x000A      ORRS     R0,R0,#0xA
   \   0000003A   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   0000003E   0xE032             B.N      ??AccSetRate_2
    182          	}else if(rate == RATE_33){
   \                     ??AccSetRate_3: (+1)
   \   00000040   0x2D1E             CMP      R5,#+30
   \   00000042   0xD106             BNE.N    ??AccSetRate_4
    183          		data2 = data1 | BMI160_ACC_CONF_RATE_400;
   \   00000044   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000048   0xF050 0x000A      ORRS     R0,R0,#0xA
   \   0000004C   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   00000050   0xE029             B.N      ??AccSetRate_2
    184          	}else if(rate == RATE_25){
   \                     ??AccSetRate_4: (+1)
   \   00000052   0x2D28             CMP      R5,#+40
   \   00000054   0xD106             BNE.N    ??AccSetRate_5
    185          		data2 = data1 | BMI160_ACC_CONF_RATE_100;
   \   00000056   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000005E   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   00000062   0xE020             B.N      ??AccSetRate_2
    186          	}else if(rate == UI){
   \                     ??AccSetRate_5: (+1)
   \   00000064   0x2D3C             CMP      R5,#+60
   \   00000066   0xD106             BNE.N    ??AccSetRate_6
    187          		data2 = data1 | BMI160_ACC_CONF_RATE_100;
   \   00000068   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000006C   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000070   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   00000074   0xE017             B.N      ??AccSetRate_2
    188          	}else if(rate == RATE_10){
   \                     ??AccSetRate_6: (+1)
   \   00000076   0x2D64             CMP      R5,#+100
   \   00000078   0xD106             BNE.N    ??AccSetRate_7
    189          		data2 = data1 | BMI160_ACC_CONF_RATE_100;
   \   0000007A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000007E   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000082   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   00000086   0xE00E             B.N      ??AccSetRate_2
    190          	}else if(rate == NORMAL){
   \                     ??AccSetRate_7: (+1)
   \   00000088   0x2DC8             CMP      R5,#+200
   \   0000008A   0xD106             BNE.N    ??AccSetRate_8
    191          		data2 = data1 | BMI160_ACC_CONF_RATE_100;
   \   0000008C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000090   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000094   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   00000098   0xE005             B.N      ??AccSetRate_2
    192          	}else{
    193          		data2 = data1 | BMI160_ACC_CONF_RATE_100;
   \                     ??AccSetRate_8: (+1)
   \   0000009A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000009E   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   000000A2   0xF88D 0x0001      STRB     R0,[SP, #+1]
    194          	}
    195          	if(Write(pHandle,BMI160_ACC_CONF_REG,&data2 ,1)){
   \                     ??AccSetRate_2: (+1)
   \   000000A6   0x2301             MOVS     R3,#+1
   \   000000A8   0xF10D 0x0201      ADD      R2,SP,#+1
   \   000000AC   0x2140             MOVS     R1,#+64
   \   000000AE   0x0020             MOVS     R0,R4
   \   000000B0   0x.... 0x....      BL       Write
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD002             BEQ.N    ??AccSetRate_9
    196          		return CWM_ERROR_SPI;
   \   000000B8   0xF07F 0x0006      MVNS     R0,#+6
   \   000000BC   0xE015             B.N      ??AccSetRate_10
    197          	}
    198          	if(!Read(pHandle,BMI160_ACC_CONF_REG,&data1,1)){
   \                     ??AccSetRate_9: (+1)
   \   000000BE   0x2301             MOVS     R3,#+1
   \   000000C0   0x466A             MOV      R2,SP
   \   000000C2   0x2140             MOVS     R1,#+64
   \   000000C4   0x0020             MOVS     R0,R4
   \   000000C6   0x.... 0x....      BL       Read
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD10C             BNE.N    ??AccSetRate_11
    199          		if(data1 !=data2){
   \   000000CE   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000D2   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   000000D6   0x4288             CMP      R0,R1
   \   000000D8   0xD006             BEQ.N    ??AccSetRate_11
    200          			if(rty<3){rty++; goto retry;}else{ return CWM_ERROR_SPI;}
   \   000000DA   0x2E03             CMP      R6,#+3
   \   000000DC   0xDA01             BGE.N    ??AccSetRate_12
   \   000000DE   0x1C76             ADDS     R6,R6,#+1
   \   000000E0   0xE799             B.N      ??AccSetRate_0
   \                     ??AccSetRate_12: (+1)
   \   000000E2   0xF07F 0x0006      MVNS     R0,#+6
   \   000000E6   0xE000             B.N      ??AccSetRate_10
    201          		}
    202          	}
    203          	return 0 ;
   \                     ??AccSetRate_11: (+1)
   \   000000E8   0x2000             MOVS     R0,#+0
   \                     ??AccSetRate_10: (+1)
   \   000000EA   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    204          }
    205          

   \                                 In section .text, align 2, keep-with-next
    206          static int AccInit(pDriverHandle_t pHandle, void *data)
    207          {
   \                     AccInit: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    208              BMI160.infoAccEn = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      LDR.W    R3,??DataTable11_2
   \   00000008   0x7018             STRB     R0,[R3, #+0]
    209          
    210              return 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR               ;; return
    211          }
    212          

   \                                 In section .text, align 2, keep-with-next
    213          int AccPowerOnCheck(pDriverHandle_t pHandle){
   \                     AccPowerOnCheck: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    214              uint8_t data1 = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
    215              uint8_t data2 = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    216              int rty = 0;
   \   00000010   0x2500             MOVS     R5,#+0
    217          
    218              if(Read(pHandle, BMI160_PMU_STATUS_REG,&data2,1) ){
   \   00000012   0x2301             MOVS     R3,#+1
   \   00000014   0xF10D 0x0201      ADD      R2,SP,#+1
   \   00000018   0x2103             MOVS     R1,#+3
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       Read
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD002             BEQ.N    ??AccPowerOnCheck_0
    219                  return CWM_ERROR_SPI;
   \   00000024   0xF07F 0x0006      MVNS     R0,#+6
   \   00000028   0xE067             B.N      ??AccPowerOnCheck_1
    220              }
    221              if(((data2&BMI160_PMU_STATUS_ACC_MASK)>>BMI160_PMU_STATUS_ACC_SHIFT)==BMI160_PMU_ACC_NORMAL){
   \                     ??AccPowerOnCheck_0: (+1)
   \   0000002A   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000002E   0xF3C0 0x1001      UBFX     R0,R0,#+4,#+2
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD101             BNE.N    ??AccPowerOnCheck_2
    222                  return 0;//power mode correct
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xE05E             B.N      ??AccPowerOnCheck_1
    223              }    
    224          retry:
    225          	data1 =BMI160_CMD_ACC_NORMAL;
   \                     ??AccPowerOnCheck_2: (+1)
   \   0000003C   0x2011             MOVS     R0,#+17
   \   0000003E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    226          	if(Write(pHandle,BMI160_CMD_REG,&data1 ,1) ){
   \   00000042   0x2301             MOVS     R3,#+1
   \   00000044   0x466A             MOV      R2,SP
   \   00000046   0x217E             MOVS     R1,#+126
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       Write
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD002             BEQ.N    ??AccPowerOnCheck_3
    227          		return CWM_ERROR_SPI;
   \   00000052   0xF07F 0x0006      MVNS     R0,#+6
   \   00000056   0xE050             B.N      ??AccPowerOnCheck_1
    228          	}
    229          	sleep(pHandle, BMI160_CMD_ACC_SWITCH_TIME);
   \                     ??AccPowerOnCheck_3: (+1)
   \   00000058   0x2128             MOVS     R1,#+40
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x.... 0x....      BL       sleep
    230          	if(Read(pHandle, BMI160_PMU_STATUS_REG,&data2,1) ){
   \   00000060   0x2301             MOVS     R3,#+1
   \   00000062   0xF10D 0x0201      ADD      R2,SP,#+1
   \   00000066   0x2103             MOVS     R1,#+3
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0x.... 0x....      BL       Read
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD002             BEQ.N    ??AccPowerOnCheck_4
    231          		return CWM_ERROR_SPI;
   \   00000072   0xF07F 0x0006      MVNS     R0,#+6
   \   00000076   0xE040             B.N      ??AccPowerOnCheck_1
    232          	}
    233          	if(((data2&BMI160_PMU_STATUS_ACC_MASK)>>BMI160_PMU_STATUS_ACC_SHIFT)!=BMI160_PMU_ACC_NORMAL){
   \                     ??AccPowerOnCheck_4: (+1)
   \   00000078   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000007C   0xF3C0 0x1001      UBFX     R0,R0,#+4,#+2
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000082   0x2801             CMP      R0,#+1
   \   00000084   0xD006             BEQ.N    ??AccPowerOnCheck_5
    234          		if(rty<3){rty++; goto retry;}else{ return CWM_ERROR_SPI;}
   \   00000086   0x2D03             CMP      R5,#+3
   \   00000088   0xDA01             BGE.N    ??AccPowerOnCheck_6
   \   0000008A   0x1C6D             ADDS     R5,R5,#+1
   \   0000008C   0xE7D6             B.N      ??AccPowerOnCheck_2
   \                     ??AccPowerOnCheck_6: (+1)
   \   0000008E   0xF07F 0x0006      MVNS     R0,#+6
   \   00000092   0xE032             B.N      ??AccPowerOnCheck_1
    235          	}
    236          
    237          //switch to 4G	
    238          	data1 =BMI160_ACC_RANGE_4G;
   \                     ??AccPowerOnCheck_5: (+1)
   \   00000094   0x2005             MOVS     R0,#+5
   \   00000096   0xF88D 0x0000      STRB     R0,[SP, #+0]
    239          	if(Write(pHandle, BMI160_ACC_RANGE_REG,&data1 ,1) ){
   \   0000009A   0x2301             MOVS     R3,#+1
   \   0000009C   0x466A             MOV      R2,SP
   \   0000009E   0x2141             MOVS     R1,#+65
   \   000000A0   0x0020             MOVS     R0,R4
   \   000000A2   0x.... 0x....      BL       Write
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD002             BEQ.N    ??AccPowerOnCheck_7
    240          		return CWM_ERROR_SPI;
   \   000000AA   0xF07F 0x0006      MVNS     R0,#+6
   \   000000AE   0xE024             B.N      ??AccPowerOnCheck_1
    241          	}
    242          
    243          	data1 =0x00;
   \                     ??AccPowerOnCheck_7: (+1)
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xF88D 0x0000      STRB     R0,[SP, #+0]
    244          	if(Write(pHandle,0x6C,&data1 ,1) ){
   \   000000B6   0x2301             MOVS     R3,#+1
   \   000000B8   0x466A             MOV      R2,SP
   \   000000BA   0x216C             MOVS     R1,#+108
   \   000000BC   0x0020             MOVS     R0,R4
   \   000000BE   0x.... 0x....      BL       Write
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD002             BEQ.N    ??AccPowerOnCheck_8
    245          		return CWM_ERROR_SPI;
   \   000000C6   0xF07F 0x0006      MVNS     R0,#+6
   \   000000CA   0xE016             B.N      ??AccPowerOnCheck_1
    246          	}
    247              if(AccSetRate(pHandle, BMI160.accRate)){
   \                     ??AccPowerOnCheck_8: (+1)
   \   000000CC   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   000000D0   0x7841             LDRB     R1,[R0, #+1]
   \   000000D2   0x0020             MOVS     R0,R4
   \   000000D4   0x.... 0x....      BL       AccSetRate
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD002             BEQ.N    ??AccPowerOnCheck_9
    248                  return CWM_ERROR_SPI;
   \   000000DC   0xF07F 0x0006      MVNS     R0,#+6
   \   000000E0   0xE00B             B.N      ??AccPowerOnCheck_1
    249              }
    250              if(AccSetMode(pHandle, BMI160.accMode)){
   \                     ??AccPowerOnCheck_9: (+1)
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   000000E6   0x7881             LDRB     R1,[R0, #+2]
   \   000000E8   0x0020             MOVS     R0,R4
   \   000000EA   0x.... 0x....      BL       AccSetMode
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD002             BEQ.N    ??AccPowerOnCheck_10
    251                  return CWM_ERROR_SPI;
   \   000000F2   0xF07F 0x0006      MVNS     R0,#+6
   \   000000F6   0xE000             B.N      ??AccPowerOnCheck_1
    252              }
    253              return 0;
   \                     ??AccPowerOnCheck_10: (+1)
   \   000000F8   0x2000             MOVS     R0,#+0
   \                     ??AccPowerOnCheck_1: (+1)
   \   000000FA   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    254          }
    255          

   \                                 In section .text, align 2, keep-with-next
    256          static int AccEnable(pDriverHandle_t pHandle, void *data)
    257          {
   \                     AccEnable: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    258          	uint8_t data1 = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    259          	uint8_t data2 = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF88D 0x0001      STRB     R0,[SP, #+1]
    260          	int rty = 0;
   \   00000014   0x2600             MOVS     R6,#+0
    261          	
    262          	if(BMI160.infoAccEn != 0){
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD011             BEQ.N    ??AccEnable_0
    263                      if(AccPowerOnCheck(pHandle)){
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       AccPowerOnCheck
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD002             BEQ.N    ??AccEnable_1
    264                          return CWM_ERROR_SPI;
   \   0000002A   0xF07F 0x0006      MVNS     R0,#+6
   \   0000002E   0xE05A             B.N      ??AccEnable_2
    265                      }
    266          		BMI160.infoAccEn |= ((uint8_t)(1)<<BMI160_ACC_NORMAL_EN);
   \                     ??AccEnable_1: (+1)
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   0000003E   0x7008             STRB     R0,[R1, #+0]
    267          		return 0;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xE050             B.N      ??AccEnable_2
    268          	}
    269          
    270          retry:
    271          	data1 =BMI160_CMD_ACC_NORMAL;
   \                     ??AccEnable_0: (+1)
   \   00000044   0x2011             MOVS     R0,#+17
   \   00000046   0xF88D 0x0000      STRB     R0,[SP, #+0]
    272          	if(Write(pHandle, BMI160_CMD_REG,&data1 ,1) ){
   \   0000004A   0x2301             MOVS     R3,#+1
   \   0000004C   0x466A             MOV      R2,SP
   \   0000004E   0x217E             MOVS     R1,#+126
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       Write
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD002             BEQ.N    ??AccEnable_3
    273          		return CWM_ERROR_SPI;
   \   0000005A   0xF07F 0x0006      MVNS     R0,#+6
   \   0000005E   0xE042             B.N      ??AccEnable_2
    274          	}
    275          	sleep(pHandle, BMI160_CMD_ACC_SWITCH_TIME);
   \                     ??AccEnable_3: (+1)
   \   00000060   0x2128             MOVS     R1,#+40
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0x.... 0x....      BL       sleep
    276          	if(Read(pHandle, BMI160_PMU_STATUS_REG,&data2,1) ){
   \   00000068   0x2301             MOVS     R3,#+1
   \   0000006A   0xF10D 0x0201      ADD      R2,SP,#+1
   \   0000006E   0x2103             MOVS     R1,#+3
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0x.... 0x....      BL       Read
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD002             BEQ.N    ??AccEnable_4
    277          		return CWM_ERROR_SPI;
   \   0000007A   0xF07F 0x0006      MVNS     R0,#+6
   \   0000007E   0xE032             B.N      ??AccEnable_2
    278          	}
    279          	if(((data2&BMI160_PMU_STATUS_ACC_MASK)>>BMI160_PMU_STATUS_ACC_SHIFT)!=BMI160_PMU_ACC_NORMAL){
   \                     ??AccEnable_4: (+1)
   \   00000080   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000084   0xF3C0 0x1001      UBFX     R0,R0,#+4,#+2
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0x2801             CMP      R0,#+1
   \   0000008C   0xD006             BEQ.N    ??AccEnable_5
    280          		if(rty<3){rty++; goto retry;}else{ return CWM_ERROR_SPI;}
   \   0000008E   0x2E03             CMP      R6,#+3
   \   00000090   0xDA01             BGE.N    ??AccEnable_6
   \   00000092   0x1C76             ADDS     R6,R6,#+1
   \   00000094   0xE7D6             B.N      ??AccEnable_0
   \                     ??AccEnable_6: (+1)
   \   00000096   0xF07F 0x0006      MVNS     R0,#+6
   \   0000009A   0xE024             B.N      ??AccEnable_2
    281          	}
    282          
    283          //switch to 4G	
    284          	data1 =BMI160_ACC_RANGE_4G;
   \                     ??AccEnable_5: (+1)
   \   0000009C   0x2005             MOVS     R0,#+5
   \   0000009E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    285          	if(Write(pHandle,BMI160_ACC_RANGE_REG,&data1 ,1) ){
   \   000000A2   0x2301             MOVS     R3,#+1
   \   000000A4   0x466A             MOV      R2,SP
   \   000000A6   0x2141             MOVS     R1,#+65
   \   000000A8   0x0020             MOVS     R0,R4
   \   000000AA   0x.... 0x....      BL       Write
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD002             BEQ.N    ??AccEnable_7
    286          		return CWM_ERROR_SPI;
   \   000000B2   0xF07F 0x0006      MVNS     R0,#+6
   \   000000B6   0xE016             B.N      ??AccEnable_2
    287          	}
    288          
    289          	data1 =0x00;
   \                     ??AccEnable_7: (+1)
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xF88D 0x0000      STRB     R0,[SP, #+0]
    290          	if(Write(pHandle,0x6C,&data1 ,1) ){
   \   000000BE   0x2301             MOVS     R3,#+1
   \   000000C0   0x466A             MOV      R2,SP
   \   000000C2   0x216C             MOVS     R1,#+108
   \   000000C4   0x0020             MOVS     R0,R4
   \   000000C6   0x.... 0x....      BL       Write
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD002             BEQ.N    ??AccEnable_8
    291          		return CWM_ERROR_SPI;
   \   000000CE   0xF07F 0x0006      MVNS     R0,#+6
   \   000000D2   0xE008             B.N      ??AccEnable_2
    292          	}
    293          	BMI160.infoAccEn |= ((uint8_t)(1)<<BMI160_ACC_NORMAL_EN);
   \                     ??AccEnable_8: (+1)
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   000000D8   0x7800             LDRB     R0,[R0, #+0]
   \   000000DA   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   000000E2   0x7008             STRB     R0,[R1, #+0]
    294          	return 0 ;
   \   000000E4   0x2000             MOVS     R0,#+0
   \                     ??AccEnable_2: (+1)
   \   000000E6   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    295          }
    296          

   \                                 In section .text, align 2, keep-with-next
    297          static int AccDisable(pDriverHandle_t pHandle, void *data)
    298          {	
   \                     AccDisable: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    299              uint8_t data1 = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0001      STRB     R0,[SP, #+1]
    300              uint8_t data2 = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF88D 0x0000      STRB     R0,[SP, #+0]
    301              int rty = 0;
   \   00000014   0x2600             MOVS     R6,#+0
    302              BMI160.infoAccEn &= ~(1<<BMI160_ACC_NORMAL_EN);
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   00000024   0x7008             STRB     R0,[R1, #+0]
    303              if(BMI160.infoAccEn != 0){
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD009             BEQ.N    ??AccDisable_0
    304                  if(AccPowerOnCheck(pHandle)){
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       AccPowerOnCheck
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD002             BEQ.N    ??AccDisable_1
    305                      return CWM_ERROR_SPI;
   \   0000003A   0xF07F 0x0006      MVNS     R0,#+6
   \   0000003E   0xE02E             B.N      ??AccDisable_2
    306                  }
    307                  return 0;
   \                     ??AccDisable_1: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xE02C             B.N      ??AccDisable_2
    308              }
    309              
    310          retry:
    311              data1 =BMI160_CMD_ACC_SUSPEND;
   \                     ??AccDisable_0: (+1)
   \   00000044   0x2010             MOVS     R0,#+16
   \   00000046   0xF88D 0x0001      STRB     R0,[SP, #+1]
    312              if(Write(pHandle, BMI160_CMD_REG,&data1 ,1) ){
   \   0000004A   0x2301             MOVS     R3,#+1
   \   0000004C   0xF10D 0x0201      ADD      R2,SP,#+1
   \   00000050   0x217E             MOVS     R1,#+126
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       Write
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD002             BEQ.N    ??AccDisable_3
    313                  return CWM_ERROR_SPI;
   \   0000005C   0xF07F 0x0006      MVNS     R0,#+6
   \   00000060   0xE01D             B.N      ??AccDisable_2
    314              }
    315              sleep(pHandle, BMI160_CMD_ACC_SWITCH_TIME);
   \                     ??AccDisable_3: (+1)
   \   00000062   0x2128             MOVS     R1,#+40
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x.... 0x....      BL       sleep
    316              if(Read(pHandle, BMI160_PMU_STATUS_REG,&data2,1) ){
   \   0000006A   0x2301             MOVS     R3,#+1
   \   0000006C   0x466A             MOV      R2,SP
   \   0000006E   0x2103             MOVS     R1,#+3
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0x.... 0x....      BL       Read
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD002             BEQ.N    ??AccDisable_4
    317                  return CWM_ERROR_SPI;
   \   0000007A   0xF07F 0x0006      MVNS     R0,#+6
   \   0000007E   0xE00E             B.N      ??AccDisable_2
    318              }
    319              if(((data2&BMI160_PMU_STATUS_ACC_MASK)>>BMI160_PMU_STATUS_ACC_SHIFT)!=BMI160_PMU_ACC_SUSPEND){
   \                     ??AccDisable_4: (+1)
   \   00000080   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000084   0xF3C0 0x1001      UBFX     R0,R0,#+4,#+2
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD006             BEQ.N    ??AccDisable_5
    320                  if(rty<3){rty++; goto retry;}else{ return CWM_ERROR_SPI;}
   \   0000008E   0x2E03             CMP      R6,#+3
   \   00000090   0xDA01             BGE.N    ??AccDisable_6
   \   00000092   0x1C76             ADDS     R6,R6,#+1
   \   00000094   0xE7D6             B.N      ??AccDisable_0
   \                     ??AccDisable_6: (+1)
   \   00000096   0xF07F 0x0006      MVNS     R0,#+6
   \   0000009A   0xE000             B.N      ??AccDisable_2
    321              }
    322              return 0 ;
   \                     ??AccDisable_5: (+1)
   \   0000009C   0x2000             MOVS     R0,#+0
   \                     ??AccDisable_2: (+1)
   \   0000009E   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    323          }
    324          

   \                                 In section .text, align 2, keep-with-next
    325          static void accDataVerify(pDriverHandle_t pHandle, int16_t *datas16_raw)
    326          {
   \                     accDataVerify: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    327              static int16_t Bmi160Accraw[3] = {0};
    328              static uint64_t Bmi160Acctime = 0;
    329              static uint8_t Bmi160AccCount = 0;
    330          
    331              if(((Bmi160Accraw[0] == datas16_raw[0]) && (Bmi160Accraw[1] == datas16_raw[1]) && (Bmi160Accraw[2] == datas16_raw[2])))
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \   0000000A   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   0000000E   0xF9B5 0x1000      LDRSH    R1,[R5, #+0]
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD14F             BNE.N    ??accDataVerify_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \   0000001A   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   0000001E   0xF9B5 0x1002      LDRSH    R1,[R5, #+2]
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD147             BNE.N    ??accDataVerify_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \   0000002A   0xF9B0 0x0004      LDRSH    R0,[R0, #+4]
   \   0000002E   0xF9B5 0x1004      LDRSH    R1,[R5, #+4]
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xD13F             BNE.N    ??accDataVerify_0
    332              {
    333                  Bmi160AccCount ++;
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable11_4
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x1C40             ADDS     R0,R0,#+1
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable11_4
   \   00000042   0x7008             STRB     R0,[R1, #+0]
    334                  if(Bmi160Acctime ==0){
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable11_5
   \   00000048   0xE9D0 0x0100      LDRD     R0,R1,[R0, #+0]
   \   0000004C   0x2200             MOVS     R2,#+0
   \   0000004E   0x2300             MOVS     R3,#+0
   \   00000050   0x4299             CMP      R1,R3
   \   00000052   0xD109             BNE.N    ??accDataVerify_1
   \   00000054   0x4290             CMP      R0,R2
   \   00000056   0xD107             BNE.N    ??accDataVerify_1
    335                  //initial error start time.
    336                  Bmi160Acctime =getTimeUs(pHandle);
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0x.... 0x....      BL       getTimeUs
   \   0000005E   0x.... 0x....      LDR.W    R2,??DataTable11_5
   \   00000062   0xE9C2 0x0100      STRD     R0,R1,[R2, #+0]
   \   00000066   0xE03C             B.N      ??accDataVerify_2
    337                  }else if(((getTimeUs(pHandle) -Bmi160Acctime) > 2000000) && (Bmi160AccCount >=10)){
   \                     ??accDataVerify_1: (+1)
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0x.... 0x....      BL       getTimeUs
   \   0000006E   0x.... 0x....      LDR.W    R2,??DataTable11_5
   \   00000072   0xE9D2 0x2300      LDRD     R2,R3,[R2, #+0]
   \   00000076   0x1A80             SUBS     R0,R0,R2
   \   00000078   0x4199             SBCS     R1,R1,R3
   \   0000007A   0x.... 0x....      LDR.W    R2,??DataTable11_6  ;; 0x1e8481
   \   0000007E   0x2300             MOVS     R3,#+0
   \   00000080   0x4299             CMP      R1,R3
   \   00000082   0xD32E             BCC.N    ??accDataVerify_2
   \   00000084   0xD801             BHI.N    ??accDataVerify_3
   \   00000086   0x4290             CMP      R0,R2
   \   00000088   0xD32B             BCC.N    ??accDataVerify_2
   \                     ??accDataVerify_3: (+1)
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable11_4
   \   0000008E   0x7800             LDRB     R0,[R0, #+0]
   \   00000090   0x280A             CMP      R0,#+10
   \   00000092   0xDB26             BLT.N    ??accDataVerify_2
    338                      Bmi160Acctime = 0;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x2100             MOVS     R1,#+0
   \   00000098   0x.... 0x....      LDR.W    R2,??DataTable11_5
   \   0000009C   0xE9C2 0x0100      STRD     R0,R1,[R2, #+0]
    339                      Bmi160AccCount = 0;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable11_4
   \   000000A6   0x7008             STRB     R0,[R1, #+0]
    340                      error(pHandle, DATA_BLOCK, 0);
   \   000000A8   0x2200             MOVS     R2,#+0
   \   000000AA   0xF07F 0x0104      MVNS     R1,#+4
   \   000000AE   0x0020             MOVS     R0,R4
   \   000000B0   0x.... 0x....      BL       error
   \   000000B4   0xE015             B.N      ??accDataVerify_2
    341                  }
    342              }else{
    343                  //reset value, because data not the same or error.
    344                  Bmi160Accraw[0] = datas16_raw[0];
   \                     ??accDataVerify_0: (+1)
   \   000000B6   0x8828             LDRH     R0,[R5, #+0]
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   000000BC   0x8008             STRH     R0,[R1, #+0]
    345                  Bmi160Accraw[1] = datas16_raw[1];
   \   000000BE   0x8868             LDRH     R0,[R5, #+2]
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   000000C4   0x8048             STRH     R0,[R1, #+2]
    346                  Bmi160Accraw[2] = datas16_raw[2];
   \   000000C6   0x88A8             LDRH     R0,[R5, #+4]
   \   000000C8   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   000000CC   0x8088             STRH     R0,[R1, #+4]
    347                  Bmi160Acctime = 0;
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x2100             MOVS     R1,#+0
   \   000000D2   0x.... 0x....      LDR.W    R2,??DataTable11_5
   \   000000D6   0xE9C2 0x0100      STRD     R0,R1,[R2, #+0]
    348                  Bmi160AccCount = 0;
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0x.... 0x....      LDR.W    R1,??DataTable11_4
   \   000000E0   0x7008             STRB     R0,[R1, #+0]
    349              }
    350          }
   \                     ??accDataVerify_2: (+1)
   \   000000E2   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .bss, align 4
   \                     `accDataVerify::Bmi160Accraw`:
   \   00000000                      DS8 8

   \                                 In section .bss, align 8
   \                     `accDataVerify::Bmi160Acctime`:
   \   00000000                      DS8 8

   \                                 In section .bss, align 1
   \                     `accDataVerify::Bmi160AccCount`:
   \   00000000                      DS8 1
    351          

   \                                 In section .text, align 4, keep-with-next
    352          int DriverBmi160AccGetData(pDriverHandle_t pHandle, void *data){
   \                     DriverBmi160AccGetData: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB088             SUB      SP,SP,#+32
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
    353              uint8_t tmpreg[6] ={0};
   \   0000000A   0xA802             ADD      R0,SP,#+8
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0xE9C0 0x1200      STRD     R1,R2,[R0, #+0]
    354              int16_t datas16_raw[3];
    355              float	senData[3];
    356              int i=0;
   \   00000014   0x2600             MOVS     R6,#+0
    357              if(!Read(pHandle, BMI160_ACC_DATA_14_ACC_XL_REG,tmpreg,6)){
   \   00000016   0x2306             MOVS     R3,#+6
   \   00000018   0xAA02             ADD      R2,SP,#+8
   \   0000001A   0x2112             MOVS     R1,#+18
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       Read
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD156             BNE.N    ??DriverBmi160AccGetData_0
    358                  for(i=0; i<3; i++){
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x0006             MOVS     R6,R0
   \                     ??DriverBmi160AccGetData_1: (+1)
   \   0000002A   0x2E03             CMP      R6,#+3
   \   0000002C   0xDA0F             BGE.N    ??DriverBmi160AccGetData_2
    359                      datas16_raw[i] = (int16_t)((((int16_t)((signed char)tmpreg[2*i+1]))<< 8) | (tmpreg[2*i]));
   \   0000002E   0xA802             ADD      R0,SP,#+8
   \   00000030   0xEB00 0x0046      ADD      R0,R0,R6, LSL #+1
   \   00000034   0xF990 0x0001      LDRSB    R0,[R0, #+1]
   \   00000038   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000003A   0xA902             ADD      R1,SP,#+8
   \   0000003C   0xF811 0x1016      LDRB     R1,[R1, R6, LSL #+1]
   \   00000040   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000044   0x4669             MOV      R1,SP
   \   00000046   0xF821 0x0016      STRH     R0,[R1, R6, LSL #+1]
    360                  } 
   \   0000004A   0x1C76             ADDS     R6,R6,#+1
   \   0000004C   0xE7ED             B.N      ??DriverBmi160AccGetData_1
    361                  senData[0] = (float)datas16_raw[0] * BMI160_ACC_CONVERT_4G;
   \                     ??DriverBmi160AccGetData_2: (+1)
   \   0000004E   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   00000052   0xEE00 0x0A10      VMOV     S0,R0
   \   00000056   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000005A   0xEDDF 0x....      VLDR.W   S1,??DataTable9  ;; 0x411ce7d5
   \   0000005E   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000062   0xEDDF 0x....      VLDR.W   S1,??DataTable9_1  ;; 0x46000000
   \   00000066   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   0000006A   0xED8D 0x0A04      VSTR     S0,[SP, #+16]
    362                  senData[1] = (float)datas16_raw[1] * BMI160_ACC_CONVERT_4G;
   \   0000006E   0xF9BD 0x0002      LDRSH    R0,[SP, #+2]
   \   00000072   0xEE00 0x0A10      VMOV     S0,R0
   \   00000076   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000007A   0xEDDF 0x....      VLDR.W   S1,??DataTable9  ;; 0x411ce7d5
   \   0000007E   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000082   0xEDDF 0x....      VLDR.W   S1,??DataTable9_1  ;; 0x46000000
   \   00000086   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   0000008A   0xED8D 0x0A05      VSTR     S0,[SP, #+20]
    363                  senData[2] = (float)datas16_raw[2] * BMI160_ACC_CONVERT_4G;
   \   0000008E   0xF9BD 0x0004      LDRSH    R0,[SP, #+4]
   \   00000092   0xEE00 0x0A10      VMOV     S0,R0
   \   00000096   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000009A   0xEDDF 0x....      VLDR.W   S1,??DataTable9  ;; 0x411ce7d5
   \   0000009E   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   000000A2   0xEDDF 0x....      VLDR.W   S1,??DataTable9_1  ;; 0x46000000
   \   000000A6   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   000000AA   0xED8D 0x0A06      VSTR     S0,[SP, #+24]
    364                  senDataCb(pHandle, senData, NULL);
   \   000000AE   0x2200             MOVS     R2,#+0
   \   000000B0   0xA904             ADD      R1,SP,#+16
   \   000000B2   0x0020             MOVS     R0,R4
   \   000000B4   0x.... 0x....      BL       senDataCb
    365                  accDataVerify(pHandle, datas16_raw);
   \   000000B8   0x4669             MOV      R1,SP
   \   000000BA   0x0020             MOVS     R0,R4
   \   000000BC   0x.... 0x....      BL       accDataVerify
    366                  memcpy(data, senData, sizeof(float)*3);
   \   000000C0   0x270C             MOVS     R7,#+12
   \   000000C2   0xF10D 0x0810      ADD      R8,SP,#+16
   \   000000C6   0x003A             MOVS     R2,R7
   \   000000C8   0x4641             MOV      R1,R8
   \   000000CA   0x0028             MOVS     R0,R5
   \   000000CC   0x.... 0x....      BL       __aeabi_memcpy
    367                  return CWM_NON;
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0xE001             B.N      ??DriverBmi160AccGetData_3
    368              }
    369              return CWM_ERROR_SPI;
   \                     ??DriverBmi160AccGetData_0: (+1)
   \   000000D4   0xF07F 0x0006      MVNS     R0,#+6
   \                     ??DriverBmi160AccGetData_3: (+1)
   \   000000D8   0xB008             ADD      SP,SP,#+32
   \   000000DA   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    370          }
    371          

   \                                 In section .text, align 2, keep-with-next
    372          int AccGetStatus(pDriverHandle_t pHandle, void *data){
   \                     AccGetStatus: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    373              uint8_t tmpreg[6] ={0};
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0xE9C0 0x1200      STRD     R1,R2,[R0, #+0]
    374              if(!Read(pHandle, 0x1C,tmpreg,2)){
   \   00000012   0x2302             MOVS     R3,#+2
   \   00000014   0x466A             MOV      R2,SP
   \   00000016   0x211C             MOVS     R1,#+28
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       Read
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD10B             BNE.N    ??AccGetStatus_0
    375                  if (tmpreg[0]& (1<<2)){
   \   00000022   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000026   0x0740             LSLS     R0,R0,#+29
   \   00000028   0xD501             BPL.N    ??AccGetStatus_1
    376                      return SENSOR_INTERRUPT_MOTION;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xE006             B.N      ??AccGetStatus_2
    377                  }else if (tmpreg[1]& (1<<7)){
   \                     ??AccGetStatus_1: (+1)
   \   0000002E   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000032   0x0600             LSLS     R0,R0,#+24
   \   00000034   0xD501             BPL.N    ??AccGetStatus_0
    378                      return SENSOR_INTERRUPT_NON_MOTION;
   \   00000036   0x2002             MOVS     R0,#+2
   \   00000038   0xE000             B.N      ??AccGetStatus_2
    379                  }
    380              }
    381              return 0;
   \                     ??AccGetStatus_0: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \                     ??AccGetStatus_2: (+1)
   \   0000003C   0xBD3E             POP      {R1-R5,PC}       ;; return
    382          }
    383          

   \                                 In section .text, align 4, keep-with-next
    384          int AccGetInfo(pDriverHandle_t pHandle, void *data){
   \                     AccGetInfo: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0xB084             SUB      SP,SP,#+16
   \   00000008   0x0004             MOVS     R4,R0
   \   0000000A   0x000D             MOVS     R5,R1
    385              uint8_t tmpreg[6] ={0};
   \   0000000C   0xA802             ADD      R0,SP,#+8
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0xE9C0 0x1200      STRD     R1,R2,[R0, #+0]
    386              int16_t datas16_raw[3];
    387              float	temperature = 0;
   \   00000016   0xED9F 0x....      VLDR.W   S16,??DataTable10  ;; 0x0
    388              uint8_t *pData = (uint8_t *)data;
   \   0000001A   0x002E             MOVS     R6,R5
    389              if(!Read(pHandle, BMI160_TEMPERATURE_0_REG,tmpreg,2)){
   \   0000001C   0x2302             MOVS     R3,#+2
   \   0000001E   0xAA02             ADD      R2,SP,#+8
   \   00000020   0x2120             MOVS     R1,#+32
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       Read
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD129             BNE.N    ??AccGetInfo_0
    390                  datas16_raw[0] = (int16_t)((((int16_t)((signed char)tmpreg[1]))<< 8) | (tmpreg[0]));
   \   0000002C   0xF99D 0x0009      LDRSB    R0,[SP, #+9]
   \   00000030   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000032   0xF89D 0x1008      LDRB     R1,[SP, #+8]
   \   00000036   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000003A   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    391                  temperature = ((float)datas16_raw[0] /512.0f)+23.0f;
   \   0000003E   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   00000042   0xEE00 0x0A10      VMOV     S0,R0
   \   00000046   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000004A   0xEDDF 0x....      VLDR.W   S1,??DataTable10_1  ;; 0x44000000
   \   0000004E   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   00000052   0xEEF3 0x0A07      VMOV.F32 S1,#23.0
   \   00000056   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   0000005A   0xEEB0 0x8A40      VMOV.F32 S16,S0
    392                  datas16_raw[0] = (int16_t)(temperature*100);
   \   0000005E   0xED9F 0x....      VLDR.W   S0,??DataTable10_2  ;; 0x42c80000
   \   00000062   0xEE28 0x0A00      VMUL.F32 S0,S16,S0
   \   00000066   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   0000006A   0xEE10 0x0A10      VMOV     R0,S0
   \   0000006E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    393                  pData[0] = datas16_raw[0];
   \   00000072   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000076   0x7030             STRB     R0,[R6, #+0]
    394                  pData[1] = datas16_raw[0]>>8;
   \   00000078   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   0000007C   0x1200             ASRS     R0,R0,#+8
   \   0000007E   0x7070             STRB     R0,[R6, #+1]
    395              }
    396              return 0 ;
   \                     ??AccGetInfo_0: (+1)
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xB004             ADD      SP,SP,#+16
   \   00000084   0xECBD 0x8B02      VPOP     {D8}
   \   00000088   0xBD70             POP      {R4-R6,PC}       ;; return
    397          }
    398          

   \                                 In section .text, align 2, keep-with-next
    399          int AccReset(pDriverHandle_t pHandle, void *data){
   \                     AccReset: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    400              return 0 ;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR               ;; return
    401          }
    402          

   \                                 In section .text, align 2, keep-with-next
    403          int AccSelftTest(pDriverHandle_t pHandle, void *data){
   \                     AccSelftTest: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    404              uint8_t data1 = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    405              uint8_t tmpreg[6] ={0};
   \   0000000E   0xA801             ADD      R0,SP,#+4
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x2200             MOVS     R2,#+0
   \   00000014   0xE9C0 0x1200      STRD     R1,R2,[R0, #+0]
    406              int16_t acc_selft_data_positive[3] ={0};
   \   00000018   0xA805             ADD      R0,SP,#+20
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0xE9C0 0x1200      STRD     R1,R2,[R0, #+0]
    407              int16_t acc_selft_data_negative[3] ={0};
   \   00000022   0xA803             ADD      R0,SP,#+12
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0xE9C0 0x1200      STRD     R1,R2,[R0, #+0]
    408              int rty = 0;
   \   0000002C   0x2600             MOVS     R6,#+0
    409              int status = NO_ERROR;
   \   0000002E   0x2700             MOVS     R7,#+0
    410              if(AccEnable(pHandle, data))
   \   00000030   0x0029             MOVS     R1,R5
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       AccEnable
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD002             BEQ.N    ??AccSelftTest_0
    411                  return I2C_FAIL;
   \   0000003C   0xF07F 0x0003      MVNS     R0,#+3
   \   00000040   0xE0DD             B.N      ??AccSelftTest_1
    412          
    413              //switch to 8G
    414              data1 =BMI160_ACC_RANGE_8G;
   \                     ??AccSelftTest_0: (+1)
   \   00000042   0x2008             MOVS     R0,#+8
   \   00000044   0xF88D 0x0000      STRB     R0,[SP, #+0]
    415              if(Write(pHandle, BMI160_ACC_RANGE_REG,&data1 ,1) )
   \   00000048   0x2301             MOVS     R3,#+1
   \   0000004A   0x466A             MOV      R2,SP
   \   0000004C   0x2141             MOVS     R1,#+65
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       Write
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD002             BEQ.N    ??AccSelftTest_2
    416                  return I2C_FAIL;
   \   00000058   0xF07F 0x0003      MVNS     R0,#+3
   \   0000005C   0xE0CF             B.N      ??AccSelftTest_1
    417              
    418              data1 =0x2c;
   \                     ??AccSelftTest_2: (+1)
   \   0000005E   0x202C             MOVS     R0,#+44
   \   00000060   0xF88D 0x0000      STRB     R0,[SP, #+0]
    419              if(Write(pHandle, 0x40,&data1 ,1) )
   \   00000064   0x2301             MOVS     R3,#+1
   \   00000066   0x466A             MOV      R2,SP
   \   00000068   0x2140             MOVS     R1,#+64
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0x.... 0x....      BL       Write
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD002             BEQ.N    ??AccSelftTest_3
    420                  return I2C_FAIL;
   \   00000074   0xF07F 0x0003      MVNS     R0,#+3
   \   00000078   0xE0C1             B.N      ??AccSelftTest_1
    421              
    422              sleep(pHandle, 100);
   \                     ??AccSelftTest_3: (+1)
   \   0000007A   0x2164             MOVS     R1,#+100
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0x.... 0x....      BL       sleep
    423          retry:
    424              
    425              status = NO_ERROR;
   \                     ??AccSelftTest_4: (+1)
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x0007             MOVS     R7,R0
    426              //test for x-axis positive
    427              data1 =BMI160_ACC_SELF_TEST_AMPT | BMI160_ACC_SELF_TEST_SIGN | BMI160_ACC_SELF_TEST_AXIS_X_EN;
   \   00000086   0x200D             MOVS     R0,#+13
   \   00000088   0xF88D 0x0000      STRB     R0,[SP, #+0]
    428              if(Write(pHandle, BMI160_SELF_TEST_REG,&data1 ,1) )
   \   0000008C   0x2301             MOVS     R3,#+1
   \   0000008E   0x466A             MOV      R2,SP
   \   00000090   0x216D             MOVS     R1,#+109
   \   00000092   0x0020             MOVS     R0,R4
   \   00000094   0x.... 0x....      BL       Write
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD002             BEQ.N    ??AccSelftTest_5
    429                  return I2C_FAIL;
   \   0000009C   0xF07F 0x0003      MVNS     R0,#+3
   \   000000A0   0xE0AD             B.N      ??AccSelftTest_1
    430              
    431              sleep(pHandle, 100);
   \                     ??AccSelftTest_5: (+1)
   \   000000A2   0x2164             MOVS     R1,#+100
   \   000000A4   0x0020             MOVS     R0,R4
   \   000000A6   0x.... 0x....      BL       sleep
    432              if(!Read(pHandle, BMI160_ACC_DATA_14_ACC_XL_REG,tmpreg,6) ){
   \   000000AA   0x2306             MOVS     R3,#+6
   \   000000AC   0xAA01             ADD      R2,SP,#+4
   \   000000AE   0x2112             MOVS     R1,#+18
   \   000000B0   0x0020             MOVS     R0,R4
   \   000000B2   0x.... 0x....      BL       Read
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD11A             BNE.N    ??AccSelftTest_6
    433                  acc_selft_data_positive[0] = (int16_t)((((int16_t)((signed char)tmpreg[1]))<< 8) | (tmpreg[0]));
   \   000000BA   0xF99D 0x0005      LDRSB    R0,[SP, #+5]
   \   000000BE   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   000000C0   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   000000C4   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000000C8   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    434                  acc_selft_data_positive[1] = (int16_t)((((int16_t)((signed char)tmpreg[3]))<< 8) | (tmpreg[2]));
   \   000000CC   0xF99D 0x0007      LDRSB    R0,[SP, #+7]
   \   000000D0   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   000000D2   0xF89D 0x1006      LDRB     R1,[SP, #+6]
   \   000000D6   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000000DA   0xF8AD 0x0016      STRH     R0,[SP, #+22]
    435                  acc_selft_data_positive[2] = (int16_t)((((int16_t)((signed char)tmpreg[5]))<< 8) | (tmpreg[4]));
   \   000000DE   0xF99D 0x0009      LDRSB    R0,[SP, #+9]
   \   000000E2   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   000000E4   0xF89D 0x1008      LDRB     R1,[SP, #+8]
   \   000000E8   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000000EC   0xF8AD 0x0018      STRH     R0,[SP, #+24]
    436              }
    437              //test for x-axis negative
    438              data1 =BMI160_ACC_SELF_TEST_AMPT | BMI160_ACC_SELF_TEST_AXIS_X_EN;
   \                     ??AccSelftTest_6: (+1)
   \   000000F0   0x2009             MOVS     R0,#+9
   \   000000F2   0xF88D 0x0000      STRB     R0,[SP, #+0]
    439              if(Write(pHandle, BMI160_SELF_TEST_REG,&data1 ,1) )
   \   000000F6   0x2301             MOVS     R3,#+1
   \   000000F8   0x466A             MOV      R2,SP
   \   000000FA   0x216D             MOVS     R1,#+109
   \   000000FC   0x0020             MOVS     R0,R4
   \   000000FE   0x.... 0x....      BL       Write
   \   00000102   0x2800             CMP      R0,#+0
   \   00000104   0xD002             BEQ.N    ??AccSelftTest_7
    440                  return I2C_FAIL;
   \   00000106   0xF07F 0x0003      MVNS     R0,#+3
   \   0000010A   0xE078             B.N      ??AccSelftTest_1
    441              
    442              sleep(pHandle, 100);
   \                     ??AccSelftTest_7: (+1)
   \   0000010C   0x2164             MOVS     R1,#+100
   \   0000010E   0x0020             MOVS     R0,R4
   \   00000110   0x.... 0x....      BL       sleep
    443              if(!Read(pHandle, BMI160_ACC_DATA_14_ACC_XL_REG,tmpreg,6) ){
   \   00000114   0x2306             MOVS     R3,#+6
   \   00000116   0xAA01             ADD      R2,SP,#+4
   \   00000118   0x2112             MOVS     R1,#+18
   \   0000011A   0x0020             MOVS     R0,R4
   \   0000011C   0x.... 0x....      BL       Read
   \   00000120   0x2800             CMP      R0,#+0
   \   00000122   0xD11A             BNE.N    ??AccSelftTest_8
    444                  acc_selft_data_negative[0] = (int16_t)((((int16_t)((signed char)tmpreg[1]))<< 8) | (tmpreg[0]));
   \   00000124   0xF99D 0x0005      LDRSB    R0,[SP, #+5]
   \   00000128   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000012A   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   0000012E   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000132   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    445                  acc_selft_data_negative[1] = (int16_t)((((int16_t)((signed char)tmpreg[3]))<< 8) | (tmpreg[2]));
   \   00000136   0xF99D 0x0007      LDRSB    R0,[SP, #+7]
   \   0000013A   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000013C   0xF89D 0x1006      LDRB     R1,[SP, #+6]
   \   00000140   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000144   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    446                  acc_selft_data_negative[2] = (int16_t)((((int16_t)((signed char)tmpreg[5]))<< 8) | (tmpreg[4]));
   \   00000148   0xF99D 0x0009      LDRSB    R0,[SP, #+9]
   \   0000014C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000014E   0xF89D 0x1008      LDRB     R1,[SP, #+8]
   \   00000152   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000156   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    447              }
    448              //////////////////////////////////////////////////////////////////////////////////////////////////
    449              //Check Criterion
    450              if(abs(acc_selft_data_positive[0] - acc_selft_data_negative[0]) <BMI160_ACC_SELF_TEST_AXIS_X_RANGE){
   \                     ??AccSelftTest_8: (+1)
   \   0000015A   0xF9BD 0x0014      LDRSH    R0,[SP, #+20]
   \   0000015E   0xF9BD 0x100C      LDRSH    R1,[SP, #+12]
   \   00000162   0x1A40             SUBS     R0,R0,R1
   \   00000164   0x.... 0x....      BL       abs
   \   00000168   0xF640 0x31B8      MOVW     R1,#+3000
   \   0000016C   0x4288             CMP      R0,R1
   \   0000016E   0xDA02             BGE.N    ??AccSelftTest_9
    451                  status = FAIL;
   \   00000170   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000174   0x0007             MOVS     R7,R0
    452              }
    453              if(abs(acc_selft_data_positive[0] - acc_selft_data_negative[0]) <BMI160_ACC_SELF_TEST_AXIS_Y_RANGE){
   \                     ??AccSelftTest_9: (+1)
   \   00000176   0xF9BD 0x0014      LDRSH    R0,[SP, #+20]
   \   0000017A   0xF9BD 0x100C      LDRSH    R1,[SP, #+12]
   \   0000017E   0x1A40             SUBS     R0,R0,R1
   \   00000180   0x.... 0x....      BL       abs
   \   00000184   0xF640 0x31B8      MOVW     R1,#+3000
   \   00000188   0x4288             CMP      R0,R1
   \   0000018A   0xDA02             BGE.N    ??AccSelftTest_10
    454                  status = FAIL;
   \   0000018C   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000190   0x0007             MOVS     R7,R0
    455              }
    456              if(abs(acc_selft_data_positive[0] - acc_selft_data_negative[0]) <BMI160_ACC_SELF_TEST_AXIS_Z_RANGE){
   \                     ??AccSelftTest_10: (+1)
   \   00000192   0xF9BD 0x0014      LDRSH    R0,[SP, #+20]
   \   00000196   0xF9BD 0x100C      LDRSH    R1,[SP, #+12]
   \   0000019A   0x1A40             SUBS     R0,R0,R1
   \   0000019C   0x.... 0x....      BL       abs
   \   000001A0   0xF240 0x51DC      MOVW     R1,#+1500
   \   000001A4   0x4288             CMP      R0,R1
   \   000001A6   0xDA02             BGE.N    ??AccSelftTest_11
    457                  status = FAIL;
   \   000001A8   0xF05F 0x30FF      MOVS     R0,#-1
   \   000001AC   0x0007             MOVS     R7,R0
    458              }
    459              if(status == FAIL){
   \                     ??AccSelftTest_11: (+1)
   \   000001AE   0xF117 0x0F01      CMN      R7,#+1
   \   000001B2   0xD103             BNE.N    ??AccSelftTest_12
    460                  if(rty<2){rty++; goto retry;}
   \   000001B4   0x2E02             CMP      R6,#+2
   \   000001B6   0xDA01             BGE.N    ??AccSelftTest_12
   \   000001B8   0x1C76             ADDS     R6,R6,#+1
   \   000001BA   0xE762             B.N      ??AccSelftTest_4
    461              }
    462              //////////////////////////////////////////////////////////////////////////////////////////////////
    463              //Disable Selft Test
    464              data1 =BMI160_SELF_TEST_DISABLE;
   \                     ??AccSelftTest_12: (+1)
   \   000001BC   0x2000             MOVS     R0,#+0
   \   000001BE   0xF88D 0x0000      STRB     R0,[SP, #+0]
    465              if(Write(pHandle, BMI160_SELF_TEST_REG,&data1 ,1) )
   \   000001C2   0x2301             MOVS     R3,#+1
   \   000001C4   0x466A             MOV      R2,SP
   \   000001C6   0x216D             MOVS     R1,#+109
   \   000001C8   0x0020             MOVS     R0,R4
   \   000001CA   0x.... 0x....      BL       Write
   \   000001CE   0x2800             CMP      R0,#+0
   \   000001D0   0xD002             BEQ.N    ??AccSelftTest_13
    466              return I2C_FAIL;
   \   000001D2   0xF07F 0x0003      MVNS     R0,#+3
   \   000001D6   0xE012             B.N      ??AccSelftTest_1
    467              
    468              //switch to 4G	
    469              data1 =BMI160_ACC_RANGE_4G;
   \                     ??AccSelftTest_13: (+1)
   \   000001D8   0x2005             MOVS     R0,#+5
   \   000001DA   0xF88D 0x0000      STRB     R0,[SP, #+0]
    470              if(Write(pHandle, BMI160_ACC_RANGE_REG,&data1 ,1) )
   \   000001DE   0x2301             MOVS     R3,#+1
   \   000001E0   0x466A             MOV      R2,SP
   \   000001E2   0x2141             MOVS     R1,#+65
   \   000001E4   0x0020             MOVS     R0,R4
   \   000001E6   0x.... 0x....      BL       Write
   \   000001EA   0x2800             CMP      R0,#+0
   \   000001EC   0xD002             BEQ.N    ??AccSelftTest_14
    471                  return I2C_FAIL;
   \   000001EE   0xF07F 0x0003      MVNS     R0,#+3
   \   000001F2   0xE004             B.N      ??AccSelftTest_1
    472              
    473              if(AccDisable(pHandle, data)){
   \                     ??AccSelftTest_14: (+1)
   \   000001F4   0x0029             MOVS     R1,R5
   \   000001F6   0x0020             MOVS     R0,R4
   \   000001F8   0x.... 0x....      BL       AccDisable
    474              }
    475              
    476          return status;
   \   000001FC   0x0038             MOVS     R0,R7
   \                     ??AccSelftTest_1: (+1)
   \   000001FE   0xB007             ADD      SP,SP,#+28
   \   00000200   0xBDF0             POP      {R4-R7,PC}       ;; return
    477          }
    478          

   \                                 In section .text, align 2, keep-with-next
    479          static int SPI_BMI160_CMD_ACC(pDriverHandle_t pHandle, int cmd, void *data)
    480          {
   \                     SPI_BMI160_CMD_ACC: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    481              switch(cmd)
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD00E             BEQ.N    ??SPI_BMI160_CMD_ACC_0
   \   0000000C   0x2D02             CMP      R5,#+2
   \   0000000E   0xD016             BEQ.N    ??SPI_BMI160_CMD_ACC_1
   \   00000010   0xD310             BCC.N    ??SPI_BMI160_CMD_ACC_2
   \   00000012   0x2D04             CMP      R5,#+4
   \   00000014   0xD021             BEQ.N    ??SPI_BMI160_CMD_ACC_3
   \   00000016   0xD317             BCC.N    ??SPI_BMI160_CMD_ACC_4
   \   00000018   0x2D06             CMP      R5,#+6
   \   0000001A   0xD02C             BEQ.N    ??SPI_BMI160_CMD_ACC_5
   \   0000001C   0xD326             BCC.N    ??SPI_BMI160_CMD_ACC_6
   \   0000001E   0x2D08             CMP      R5,#+8
   \   00000020   0xD033             BEQ.N    ??SPI_BMI160_CMD_ACC_7
   \   00000022   0xD32D             BCC.N    ??SPI_BMI160_CMD_ACC_8
   \   00000024   0x2D09             CMP      R5,#+9
   \   00000026   0xD035             BEQ.N    ??SPI_BMI160_CMD_ACC_9
   \   00000028   0xE039             B.N      ??SPI_BMI160_CMD_ACC_10
    482              {
    483                  case senInit:
    484                      return AccInit(pHandle, data);
   \                     ??SPI_BMI160_CMD_ACC_0: (+1)
   \   0000002A   0x0031             MOVS     R1,R6
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       AccInit
   \   00000032   0xE035             B.N      ??SPI_BMI160_CMD_ACC_11
    485                  case senEnable:
    486                      return AccEnable(pHandle, data);
   \                     ??SPI_BMI160_CMD_ACC_2: (+1)
   \   00000034   0x0031             MOVS     R1,R6
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       AccEnable
   \   0000003C   0xE030             B.N      ??SPI_BMI160_CMD_ACC_11
    487                  case senDisable:
    488                      return AccDisable(pHandle, data);
   \                     ??SPI_BMI160_CMD_ACC_1: (+1)
   \   0000003E   0x0031             MOVS     R1,R6
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       AccDisable
   \   00000046   0xE02B             B.N      ??SPI_BMI160_CMD_ACC_11
    489                  case senSetRate:
    490                      BMI160.accRate = ((uint8_t *)data)[0];
   \                     ??SPI_BMI160_CMD_ACC_4: (+1)
   \   00000048   0x7830             LDRB     R0,[R6, #+0]
   \   0000004A   0x....             LDR.N    R1,??DataTable11_2
   \   0000004C   0x7048             STRB     R0,[R1, #+1]
    491                      return AccSetRate(pHandle, BMI160.accRate);
   \   0000004E   0x....             LDR.N    R0,??DataTable11_2
   \   00000050   0x7841             LDRB     R1,[R0, #+1]
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       AccSetRate
   \   00000058   0xE022             B.N      ??SPI_BMI160_CMD_ACC_11
    492                  case senSetMode:
    493                      BMI160.accMode = ((int *)data)[0];
   \                     ??SPI_BMI160_CMD_ACC_3: (+1)
   \   0000005A   0x6830             LDR      R0,[R6, #+0]
   \   0000005C   0x....             LDR.N    R1,??DataTable11_2
   \   0000005E   0x7088             STRB     R0,[R1, #+2]
    494                      return AccSetMode(pHandle, BMI160.accMode);
   \   00000060   0x....             LDR.N    R0,??DataTable11_2
   \   00000062   0x7881             LDRB     R1,[R0, #+2]
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x.... 0x....      BL       AccSetMode
   \   0000006A   0xE019             B.N      ??SPI_BMI160_CMD_ACC_11
    495                  case senGetData:
    496                      return DriverBmi160AccGetData(pHandle, data);
   \                     ??SPI_BMI160_CMD_ACC_6: (+1)
   \   0000006C   0x0031             MOVS     R1,R6
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0x.... 0x....      BL       DriverBmi160AccGetData
   \   00000074   0xE014             B.N      ??SPI_BMI160_CMD_ACC_11
    497                  case senGetStatus:
    498                      return AccGetStatus(pHandle, data);
   \                     ??SPI_BMI160_CMD_ACC_5: (+1)
   \   00000076   0x0031             MOVS     R1,R6
   \   00000078   0x0020             MOVS     R0,R4
   \   0000007A   0x.... 0x....      BL       AccGetStatus
   \   0000007E   0xE00F             B.N      ??SPI_BMI160_CMD_ACC_11
    499                  case senGetInfo:
    500                      return AccGetInfo(pHandle, data);
   \                     ??SPI_BMI160_CMD_ACC_8: (+1)
   \   00000080   0x0031             MOVS     R1,R6
   \   00000082   0x0020             MOVS     R0,R4
   \   00000084   0x.... 0x....      BL       AccGetInfo
   \   00000088   0xE00A             B.N      ??SPI_BMI160_CMD_ACC_11
    501                  case senReset:
    502                      return AccReset(pHandle, data);
   \                     ??SPI_BMI160_CMD_ACC_7: (+1)
   \   0000008A   0x0031             MOVS     R1,R6
   \   0000008C   0x0020             MOVS     R0,R4
   \   0000008E   0x.... 0x....      BL       AccReset
   \   00000092   0xE005             B.N      ??SPI_BMI160_CMD_ACC_11
    503                  case senSelftest:
    504                      return AccSelftTest(pHandle, data);
   \                     ??SPI_BMI160_CMD_ACC_9: (+1)
   \   00000094   0x0031             MOVS     R1,R6
   \   00000096   0x0020             MOVS     R0,R4
   \   00000098   0x.... 0x....      BL       AccSelftTest
   \   0000009C   0xE000             B.N      ??SPI_BMI160_CMD_ACC_11
    505              }
    506          
    507              return 0;
   \                     ??SPI_BMI160_CMD_ACC_10: (+1)
   \   0000009E   0x2000             MOVS     R0,#+0
   \                     ??SPI_BMI160_CMD_ACC_11: (+1)
   \   000000A0   0xBD70             POP      {R4-R6,PC}       ;; return
    508          }

   \                                 In section .text, align 2, keep-with-next
    509          static int SPI_BMI160_CMD_GYRO(pDriverHandle_t pHandle, int cmd, void *data)
    510          {
   \                     SPI_BMI160_CMD_GYRO: (+1)
   \   00000000   0x0003             MOVS     R3,R0
    511              switch(cmd)
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD00E             BEQ.N    ??SPI_BMI160_CMD_GYRO_0
   \   00000006   0x2902             CMP      R1,#+2
   \   00000008   0xD00E             BEQ.N    ??SPI_BMI160_CMD_GYRO_1
   \   0000000A   0xD30C             BCC.N    ??SPI_BMI160_CMD_GYRO_2
   \   0000000C   0x2904             CMP      R1,#+4
   \   0000000E   0xD00D             BEQ.N    ??SPI_BMI160_CMD_GYRO_3
   \   00000010   0xD30B             BCC.N    ??SPI_BMI160_CMD_GYRO_4
   \   00000012   0x2906             CMP      R1,#+6
   \   00000014   0xD00C             BEQ.N    ??SPI_BMI160_CMD_GYRO_5
   \   00000016   0xD30A             BCC.N    ??SPI_BMI160_CMD_GYRO_6
   \   00000018   0x2908             CMP      R1,#+8
   \   0000001A   0xD00B             BEQ.N    ??SPI_BMI160_CMD_GYRO_7
   \   0000001C   0xD309             BCC.N    ??SPI_BMI160_CMD_GYRO_8
   \   0000001E   0x2909             CMP      R1,#+9
   \   00000020   0xD009             BEQ.N    ??SPI_BMI160_CMD_GYRO_9
   \   00000022   0xE008             B.N      ??SPI_BMI160_CMD_GYRO_10
    512              {
    513                  case senInit:
    514                      break;
   \                     ??SPI_BMI160_CMD_GYRO_0: (+1)
   \   00000024   0xE007             B.N      ??SPI_BMI160_CMD_GYRO_10
    515                  case senEnable:
    516                      break;
   \                     ??SPI_BMI160_CMD_GYRO_2: (+1)
   \   00000026   0xE006             B.N      ??SPI_BMI160_CMD_GYRO_10
    517                  case senDisable:
    518                      break;
   \                     ??SPI_BMI160_CMD_GYRO_1: (+1)
   \   00000028   0xE005             B.N      ??SPI_BMI160_CMD_GYRO_10
    519                  case senSetRate:
    520                      break;
   \                     ??SPI_BMI160_CMD_GYRO_4: (+1)
   \   0000002A   0xE004             B.N      ??SPI_BMI160_CMD_GYRO_10
    521                  case senSetMode:
    522                      break;
   \                     ??SPI_BMI160_CMD_GYRO_3: (+1)
   \   0000002C   0xE003             B.N      ??SPI_BMI160_CMD_GYRO_10
    523                  case senGetData:
    524                      break;
   \                     ??SPI_BMI160_CMD_GYRO_6: (+1)
   \   0000002E   0xE002             B.N      ??SPI_BMI160_CMD_GYRO_10
    525                  case senGetStatus:
    526                      break;
   \                     ??SPI_BMI160_CMD_GYRO_5: (+1)
   \   00000030   0xE001             B.N      ??SPI_BMI160_CMD_GYRO_10
    527                  case senGetInfo:
    528                      break;
   \                     ??SPI_BMI160_CMD_GYRO_8: (+1)
   \   00000032   0xE000             B.N      ??SPI_BMI160_CMD_GYRO_10
    529                  case senReset:
    530                      break;
   \                     ??SPI_BMI160_CMD_GYRO_7: (+1)
   \   00000034   0xE7FF             B.N      ??SPI_BMI160_CMD_GYRO_10
    531                  case senSelftest:
    532                      break;
    533              }
    534          
    535              return 0;
   \                     ??SPI_BMI160_CMD_GYRO_9: (+1)
   \                     ??SPI_BMI160_CMD_GYRO_10: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x4770             BX       LR               ;; return
    536          }
    537          

   \                                 In section .text, align 2, keep-with-next
    538          int SPI_BMI160_INIT(pDriverHandle_t pHandle, pDriverAPI pAPI, pDriverConfig pConfig)
    539          {
   \                     SPI_BMI160_INIT: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    540              if(pConfig->id != SPI_BMI160)
   \   00000008   0x6830             LDR      R0,[R6, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD002             BEQ.N    ??SPI_BMI160_INIT_0
    541                  return -1;
   \   0000000E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000012   0xE011             B.N      ??SPI_BMI160_INIT_1
    542              
    543              memcpy(&pHandle->config, pConfig, sizeof(DriverConfig));
   \                     ??SPI_BMI160_INIT_0: (+1)
   \   00000014   0x271C             MOVS     R7,#+28
   \   00000016   0x003A             MOVS     R2,R7
   \   00000018   0x0031             MOVS     R1,R6
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       __aeabi_memcpy
    544              pHandle->api= pAPI;
   \   00000020   0x61E5             STR      R5,[R4, #+28]
    545              
    546              if(pConfig->type == TYPE_ACCELEROMETER)
   \   00000022   0x6870             LDR      R0,[R6, #+4]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD101             BNE.N    ??SPI_BMI160_INIT_2
    547                  pHandle->Cmd = SPI_BMI160_CMD_ACC;
   \   00000028   0x....             LDR.N    R0,??DataTable11_7
   \   0000002A   0x6220             STR      R0,[R4, #+32]
    548                  
    549              if(pConfig->type == TYPE_GYROSCOPE)
   \                     ??SPI_BMI160_INIT_2: (+1)
   \   0000002C   0x6870             LDR      R0,[R6, #+4]
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD101             BNE.N    ??SPI_BMI160_INIT_3
    550                  pHandle->Cmd = SPI_BMI160_CMD_GYRO;
   \   00000032   0x....             LDR.N    R0,??DataTable11_8
   \   00000034   0x6220             STR      R0,[R4, #+32]
    551              
    552              return 0;
   \                     ??SPI_BMI160_INIT_3: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \                     ??SPI_BMI160_INIT_1: (+1)
   \   00000038   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    553          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x411CE7D5         DC32     0x411ce7d5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x46000000         DC32     0x46000000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x44000000         DC32     0x44000000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x42C80000         DC32     0x42c80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     BMI160

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x........         DC32     `accDataVerify::Bmi160Accraw`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x........         DC32     `accDataVerify::Bmi160AccCount`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x........         DC32     `accDataVerify::Bmi160Acctime`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x001E8481         DC32     0x1e8481

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   0x........         DC32     SPI_BMI160_CMD_ACC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   0x........         DC32     SPI_BMI160_CMD_GYRO

   \                                 In section .rodata, align 4
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x0000 0x0000      DC16 0, 0, 0
   \              0x0000       
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \   00000000   0x0000 0x0000      DC16 0, 0, 0
   \              0x0000       
   \   00000006   0x00 0x00          DC8 0, 0
    554          
    555          
    556          #endif /* __DriverHal_H__ */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   AccDisable
        24   -> AccPowerOnCheck
        24   -> Read
        24   -> Write
        24   -> sleep
      24   AccEnable
        24   -> AccPowerOnCheck
        24   -> Read
        24   -> Write
        24   -> sleep
      40   AccGetInfo
        40   -> Read
      24   AccGetStatus
        24   -> Read
       0   AccInit
      16   AccPowerOnCheck
        16   -> AccSetMode
        16   -> AccSetRate
        16   -> Read
        16   -> Write
        16   -> sleep
       0   AccReset
      48   AccSelftTest
        48   -> AccDisable
        48   -> AccEnable
        48   -> Read
        48   -> Write
        48   -> abs
        48   -> sleep
      16   AccSetMode
        16   -> Write
      24   AccSetRate
        24   -> Read
        24   -> Write
      56   DriverBmi160AccGetData
        56   -> Read
        56   -> __aeabi_memcpy
        56   -> accDataVerify
        56   -> senDataCb
      40   Read
        40   -- Indirect call
      16   SPI_BMI160_CMD_ACC
        16   -> AccDisable
        16   -> AccEnable
        16   -> AccGetInfo
        16   -> AccGetStatus
        16   -> AccInit
        16   -> AccReset
        16   -> AccSelftTest
        16   -> AccSetMode
        16   -> AccSetRate
        16   -> DriverBmi160AccGetData
       0   SPI_BMI160_CMD_GYRO
      24   SPI_BMI160_INIT
        24   -> __aeabi_memcpy
      40   Write
        40   -- Indirect call
      16   accDataVerify
        16   -> error
        16   -> getTimeUs
      16   error
        16   -- Indirect call
       8   getTimeUs
         8   -- Indirect call
         8 __aeabi_ldivmod
      16   senDataCb
        16   -- Indirect call
      16   sleep
        16   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable9
       4  ??DataTable9_1
       8  ?_0
       8  ?_1
       8  ?_2
       8  ?_3
       8  ?_4
       8  ?_5
      16  ?_6
      16  ?_7
     160  AccDisable
     232  AccEnable
     138  AccGetInfo
      62  AccGetStatus
      14  AccInit
     252  AccPowerOnCheck
       6  AccReset
     514  AccSelftTest
     594  AccSetMode
     236  AccSetRate
       4  BMI160
       1  Bmi160AccCount
       8  Bmi160Accraw
       8  Bmi160Acctime
     222  DriverBmi160AccGetData
      52  Read
     162  SPI_BMI160_CMD_ACC
      58  SPI_BMI160_CMD_GYRO
      58  SPI_BMI160_INIT
      52  Write
     228  accDataVerify
      20  error
      22  getTimeUs
      20  senDataCb
      22  sleep

 
    21 bytes in section .bss
    80 bytes in section .rodata
 3 180 bytes in section .text
 
 3 180 bytes of CODE  memory
    80 bytes of CONST memory
    21 bytes of DATA  memory

Errors: none
Warnings: none
